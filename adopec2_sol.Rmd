---
title: "análisis de expresión genética diferencial en tiroides"
author: "Pío Alberto Sierra Rodríguez"
date: "14/6/2020"
output: 
  pdf_document:
    toc: true
    number_sections: true
  html_document:
    df_print: paged
params:
  counts_file: ./counts.csv
  targets_file: ./targets.csv
  samples: 10
bibliography: RNA-Seq.bib
---

```{r setup,}
knitr::opts_chunk$set(echo = TRUE)
if(!(require(plyr))) 
  install.packages("plyr")
if(!(require(dplyr))) 
  install.packages("dplyr")
if(!(require(ggplot2))) 
  install.packages("ggplot2")
if(!(require(RColorBrewer))) 
  install.packages("RColorBrewer")
if(!(require(DESeq2))) 
  install.packages("DESeq2")
if(!(require(pheatmap))) 
  install.packages("pheatmap")
if(!(require(tibble))) 
  install.packages("tibble")
if(!(require(AnnotationDbi))) 
  BiocManager::install("AnnotationDbi")
if(!(require(org.Hs.eg.db))) 
BiocManager::install("org.Hs.eg.db")

```

***
**Repositorio de github:** https://github.com/piosierra/ADO-PEC2

***

# Abstract


# Objetivos

Queremos hacer un análisis de expresión genética diferencial a partir de tres muestras aleatorias de tiroides de `r params$samples` elementos, cada una de tres grupos diferentes:
* *Not infiltrated tissues* (NIT)
* *Small focal infiltrates* (SFI)
* *Extensive lymphoid infiltrates* (ELI)
  
Para ello realizaremos los contrastes:
* SFI-NIT
* ELI-NIT
* ELI-SFI
  
# Materiales y métodos

## Naturaleza de los datos

Los datos han sido obtenidos del Genotype-Tissue Expression project **[@noauthor_gtex_nodate]**. Se trata de 292 muestras pertenecientes tiroides en distintos estados de infiltración lifocitaria. Se trata de una sintomatología no muy habitual. Y de hecho el número de muestras de tipo ELI, las de mayor afectación, es reducido. **[@jimenez_varo_infiltracion_2013]**, **[@onoda_reactive_2014]**.  
Las muestras provienen de dos fuentes de datos. Por un lado las obtenidas por RNA-Seq (NGS), y por otro muestras provenientes de un trabajo separado para expresión de alelos (Allele-Specific Expression). 

## Métodos y herramientas

Hemos utilizado el lenguaje R [@onoda_reactive_2014] y las herramientas de Bioconductor, en particular la librería DebSeq2 [@love_deseq2_2020].  

 
## Workflow

### 1 Lectura de datos



### 2 Identificación de grupos y preparación de los datos

El informe está realizado a partir de dos archivos ya preparados. El archivo `r params$counts_file` contiene los conteos de las muestras del experimento para cada ensamble. El archivo `r params$targets` contiene los datos relacionados con cada una de las muestras.  
Los archivos utilizados en el estudio están correctamente formados y no faltan datos.

```{r}
# Leemos los archivos de datos
targets <- read.csv(params$targets_file)
counts <- read.csv2(params$counts_file, header = TRUE, row.names = 1)

# Comprobamos que no falta ningún dato
sum(is.na(targets))
sum(is.na(counts))

# Observamos la distribución de la media y la desviación estándar de las variables.
plot(apply(counts[-1],2,mean))
plot(apply(counts[-1],2,sd))
```

En un archivo se usa "." como separador en el nombre de las muestras, y en el otro "-". Los igualamos para poder comparar y asegurarnos de que cruzamos los datos correctamente.

```{r}
colnames(counts) <-gsub("[.]","-", colnames(counts))
```

El número de observaciones que hay de cada grupo es:
```{r}
table(targets$Group)
```
La variable que codifica el grupo ha de ser un factor, y es muy importante tener en cuenta que el primer elemento del factor será tomado como elemento de control, y será con el que se harán las comparaciones en el caso de fórmula de una sola variable.  
Para realizar los contrastes:  
* SFI-NIT  
* ELI-NIT  
Debemos de tener a NIT como primer factor. Mientras que para el último contraste:  
* ELI-SFI  
EL primer factor debe de ser SFI.  
Esta es una parte bastante delicada. Es importante para la correcta realización de las pruebas que los factores estén correctamente preparados. Esto puede comprobarse después comprobando los nombres de los contrastes preparados en el objeto *DESeqDataSet* con la instrucción `resultsNames`

```{r}
targets$Group <- as.factor(targets$Group)
targets$Group <- relevel(targets$Group, "NIT")
```


Para nuestro estudio vamos a tomar `r params$samples` muestras al azar de cada uno de los grupos.



# Resultados

# Discusión

# Conclusión

# Apéndice 1









```{r}
  
# Tomamos las muestras de targets.
set.seed(123999)
# Utilizamos la función ddply para obtener el mismo número de muestras de cada grupo del data frame,
# y devolver el resultado en un nuevo dataframe.
targets_sample <- ddply(targets,.(Group),function(x) x[sample(nrow(x),params$samples),])
table(targets_sample$Group)

# Y ahora las muestras correspondientes en counts
counts_sample <- counts[,which(colnames(counts) %in% targets_sample$Sample_Name)]

# Y finalmente las ordenamos de la misma forma según las indicaciones para usar DESeq2. 
targets_sample <- targets_sample[order(targets_sample$Sample_Name),]
counts_sample <- counts_sample[ , order(colnames(counts_sample))]

identical(colnames(counts_sample), targets_sample$Sample_Name)
```
We choose to ignore the `molecular_data_type` information. If we would like to use only RNA Seq data we should filter that field first.


# b) Quality control of the raw data. 

```{r}
# Vemos que la distribución tiene un sesgo muy pronunciado. 
# Mostramos una de las muestras como ejemplo, pero ocurre lo mismo en todas.
qplot(counts_sample[,1], geom="histogram") 
# Log base 2 is typically used as it facilitates the conversion back to the original scale: 
# a difference of 1 on the log base 2 scale corresponds to a fold change of 2 on the original count scale. 
pseudoCount = log2(counts_sample + 1)
qplot(pseudoCount[,1], geom="histogram") 

```

# c) Creating the DESeqDataSet object

We create now the DESeqDataSet object.

```{r}
dds <- DESeqDataSetFromMatrix(countData = counts_sample,
                              colData = targets_sample,
                              design = ~ Group)
```


# d) Exploratory analysis and visualization 

First, for visualization purposes, we will transform the data to make it easier to explore the relationships on it. But for the statistical analysis we will go back to use the full data.

## Pre filtering the data set for empty rows.  
We start by removing all rows which do have one or none count at all.  

```{r}
nrow(dds)
dds <- dds[ rowSums(counts(dds)) > 1, ]
nrow(dds)
```

## Variance stabilizing transformation and rlog

```{r}

vsd <- vst(dds, blind = FALSE)
rld <- rlog(dds, blind = FALSE)

dds <- estimateSizeFactors(dds)

df <- bind_rows(
  as_tibble(log2(counts(dds, normalized=TRUE)[, 1:2]+1)) %>%
         mutate(transformation = "log2(x + 1)"),
  as_tibble(assay(vsd)[, 1:2]) %>% mutate(transformation = "vst"),
  as_tibble(assay(rld)[, 1:2]) %>% mutate(transformation = "rlog"))
  
colnames(df)[1:2] <- c("x", "y")  
png("figures/vst.png", width = 680, height = 680)
print(ggplot(df, aes(x = x, y = y)) + geom_hex(bins = 80) +
  coord_fixed() + facet_grid( . ~ transformation))
dev.off()
```

We can see how genes with low counts (bottom left-hand corner) seem to be excessively variable on the ordinary logarithmic scale, while the VST and rlog compress differences for the low count genes for which the data provide little information about differential expression.  

## Samples distances

```{r}
sampleDists <- dist(t(assay(vsd)))

sampleDistMatrix <- as.matrix( sampleDists )
rownames(sampleDistMatrix) <- paste( vsd$dex, vsd$cell, sep = " - " )
colnames(sampleDistMatrix) <- NULL
colors <- colorRampPalette( rev(brewer.pal(9, "BuGn")) )(255)
png("figures/distmatrix.png", width = 680, height = 680)
print(pheatmap(sampleDistMatrix,
         clustering_distance_rows = sampleDists,
         clustering_distance_cols = sampleDists,
         col = colors))
dev.off()
```

## PCA plot

```{r}
plotPCA(vsd, intgroup = c("Group"))
```

# Differential Expression Analysis

```{r}
dds <- DESeq(dds, parallel =TRUE)
resultsNames(dds)
# Group_ELI_vs_NIT
res_ELIvNIT <- results(dds, contrast=c(0,1,0), alpha = 0.05)
# Group_SFI_vs_NIT
res_SFIvNIT <- results(dds, contrast=c(0,0,1), alpha = 0.05)

# Ahora cambiamos el orden de los factores para obtener la comparación que nos falta.

targets_sample$Group <- relevel(targets_sample$Group, "SFI")
dds <- DESeqDataSetFromMatrix(countData = counts_sample,
                              colData = targets_sample,
                              design = ~ Group)
dds <- DESeq(dds, parallel =TRUE)
resultsNames(dds)
# Group_NIT_vs_SFI
res_NITvSFI <- results(dds, contrast=c(0,1,0), alpha = 0.05)

# Group_ELI_vs_SFI
res_ELIvSFI <- results(dds, contrast=c(0,0,1), alpha = 0.05)
```
## Top genes

```{r}

topGenes_SFIvNIT <- as.data.frame(res_SFIvNIT) %>%
    rownames_to_column("GeneID") %>% 
    arrange(padj) %>% 
    head(100)
head(topGenes_SFIvNIT)
topGenes_ELIvNIT <- as.data.frame(res_ELIvNIT) %>%
    rownames_to_column("GeneID") %>% 
    arrange(padj) %>% 
    head(100)
head(topGenes_ELIvNIT)
topGenes_ELIvSFI <- as.data.frame(res_ELIvSFI) %>%
    rownames_to_column("GeneID") %>% 
    arrange(padj) %>% 
    head(100)
head(topGenes_ELIvSFI)

```

# Annotation

```{r}
columns(org.Hs.eg.db)

 # res_ELIvNIT$symbol <- mapIds(org.Hs.eg.db,
   #                   keys=row.names(res_ELIvNIT),
    #                  column="SYMBOL",
     #                 keytype="ENSEMBL",
      #                multiVals="first")
```

# Bibliografía

