---
title: "análisis de expresión genética diferencial en tiroides"
author: "Pío Alberto Sierra Rodríguez"
date: "14/6/2020"
output: 
  pdf_document:
    toc: true
    number_sections: true
  html_document:
    df_print: paged
params:
  counts_file: ./counts.csv
  targets_file: ./targets.csv
  samples: 10
bibliography: RNA-Seq.bib
---

```{r include = FALSE}
knitr::opts_chunk$set(echo = TRUE)
if(!(require(plyr))) 
  install.packages("plyr")
if(!(require(knitr))) 
  install.packages("knitr")
if(!(require(kableExtra))) 
  BiocManager::install("kableExtra")
if(!(require(dplyr))) 
  install.packages("dplyr")
if(!(require(ggplot2))) 
  install.packages("ggplot2")
if(!(require(RColorBrewer))) 
  install.packages("RColorBrewer")
if(!(require(DESeq2))) 
  install.packages("DESeq2")
if(!(require(pheatmap))) 
  install.packages("pheatmap")
if(!(require(tibble))) 
  install.packages("tibble")
if(!(require(AnnotationDbi))) 
  BiocManager::install("AnnotationDbi")
if(!(require(org.Hs.eg.db))) 
BiocManager::install("org.Hs.eg.db")

```

***
**Repositorio de github:** https://github.com/piosierra/ADO-PEC2

***

# Abstract


# Objetivos

Queremos hacer un análisis de expresión genética diferencial a partir de tres muestras aleatorias de tiroides de `r params$samples` elementos, cada una de tres grupos diferentes:  

* *Not infiltrated tissues* (NIT)
* *Small focal infiltrates* (SFI)
* *Extensive lymphoid infiltrates* (ELI)
  
Para ello realizaremos los contrastes:  

* SFI-NIT
* ELI-NIT
* ELI-SFI
  
# Materiales y métodos

## Naturaleza de los datos

Los datos han sido obtenidos del Genotype-Tissue Expression project **[@noauthor_gtex_nodate]**. Se trata de 292 muestras pertenecientes tiroides en distintos estados de infiltración lifocitaria. Se trata de una sintomatología no muy habitual. Y de hecho el número de muestras de tipo ELI, las de mayor afectación, es reducido. **[@jimenez_varo_infiltracion_2013]**, **[@onoda_reactive_2014]**.  
Las muestras provienen de dos fuentes de datos. Por un lado las obtenidas por RNA-Seq (NGS), y por otro muestras provenientes de un trabajo separado para expresión de alelos (Allele-Specific Expression). 

## Métodos y herramientas

Hemos utilizado el lenguaje R [@noauthor_r_nodate] y las herramientas de Bioconductor, en particular la librería DebSeq2 [@love_deseq2_2020].  

 
## Workflow

### Lectura de datos

El informe está realizado a partir de dos archivos ya preparados. El archivo `r params$counts_file` contiene los conteos de las muestras del experimento para cada ensamble. El archivo `r params$targets` contiene los datos relacionados con cada una de las muestras.  
Los archivos utilizados en el estudio están correctamente formados y no faltan datos.

```{r include = FALSE}
# Leemos los archivos de datos
targets <- read.csv(params$targets_file)
counts <- read.csv2(params$counts_file, header = TRUE, row.names = 1)

# Comprobamos que no falta ningún dato
sum(is.na(targets))
sum(is.na(counts))
```
```{r echo=FALSE}
# Observamos la distribución de la media y la desviación estándar de las variables.
par(mfrow=c(1,2))
plot(apply(counts[-1],2,mean), main = "Medias de las muestras", xlab="", ylab="")
plot(apply(counts[-1],2,sd), main = "Desviación típica de las muestras", xlab="", ylab="")
```

En un archivo se usa "." como separador en el nombre de las muestras, y en el otro "-". Los igualamos para poder comparar y asegurarnos de que cruzamos los datos correctamente.

```{r include=FALSE}
colnames(counts) <-gsub("[.]","-", colnames(counts))
```

### Identificación de grupos y preparación de los datos

El número de observaciones que hay de cada grupo puede verse en la tabla 1.
```{r echo = FALSE}
kable_styling(knitr::kable(table(targets$Group), booktabs = TRUE,
                            caption = 'Muestras por grupo'),font_size = 10)
```
La variable que codifica el grupo ha de ser un factor, y es muy importante tener en cuenta que el primer elemento del factor será tomado como elemento de control, y será con el que se harán las comparaciones en el caso de fórmula de una sola variable.  
Para realizar los contrastes:  

* SFI-NIT  
* ELI-NIT  

Debemos de tener a NIT como primer factor. Mientras que para el último contraste:  

* ELI-SFI  

EL primer factor debe de ser SFI.  

Esta es una parte bastante delicada. Es importante para la correcta realización de las pruebas que los factores estén correctamente preparados. Esto puede comprobarse después comprobando los nombres de los contrastes preparados en el objeto *DESeqDataSet* con la instrucción `resultsNames`

```{r include = FALSE}
targets$Group <- as.factor(targets$Group)
targets$Group <- relevel(targets$Group, "NIT")
```


Para nuestro estudio vamos a tomar `r params$samples` muestras al azar de cada uno de los grupos. Para hacerlo sin tener que dividir el dataframe nos valemos de la función `ddply`, que permite aplicar una función a distintos conjuntos de un dataframe, y crea un dataframe de salida con las respuestas. Así la usamos para generar un dataframe con el número de muestras deseadas para cada grupo.  

Es importante haber comprobado antes que el número de muestras de cada grupo excede al de muestras a coger para el experimento, ya que si no los resultados no serán correctos.

```{r include = FALSE}
  
# Tomamos las muestras de targets.
set.seed(123999)
# Utilizamos la función ddply para obtener el mismo número de muestras de cada grupo del data frame,
# y devolver el resultado en un nuevo dataframe.
targets_sample <- ddply(targets,.(Group),function(x) x[sample(nrow(x),params$samples),])
table(targets_sample$Group)

# Y ahora las muestras correspondientes en counts
counts_sample <- counts[,which(colnames(counts) %in% targets_sample$Sample_Name)]

# Y finalmente las ordenamos de la misma forma según las indicaciones para usar DESeq2. 
targets_sample <- targets_sample[order(targets_sample$Sample_Name),]
counts_sample <- counts_sample[ , order(colnames(counts_sample))]
```
Un último paso muy importante es ordernar los dos dataframes, `counts` y `targets` para que el orden de las columnas del primero coincida con el orden de las filas del otro. *DebSeq2* no hace ninguna comprobación a la hora de cruzar los datos ni utiliza ningún campo como clave, se limita a cruzar por orden fila con columna, por lo que estas han de estar correctamente ordenadas.  
En la tabla 2 se puede ver el resultado parcial para las cinco primeras columnas y filas de la ordenación efectuada.  

```{r}
kable_styling(knitr::kable(data.frame("Columnas en counts" = head(colnames(counts_sample)),
                                      "Filas en targets" = head(targets_sample$Sample_Name)),
                           booktabs = TRUE,
                           caption = 'Ejemplo de las muestras correctamente ordenadas'),font_size = 10)
identical(colnames(counts_sample), targets_sample$Sample_Name)
```

### Control de calidad de los datos en bruto

Es necesario realizar un control de la calidad de los datos antes de proceder con el experimento. 


### Creación del objeto DESeqDataSet 

DebSeq2 trabaja con un objeto *DESeqDataSet* que está construido sobre la clase *SummarizedExperiment*. Una de las diferencias fundamentales es que el objeto incluye una fórmula de diseño asociada, que será la que informa a muchas de las funciones que manipulen el objeto sobre cómo utilizar las muestras.  

Una fórmula puede ser de la forma `~ variable` donde `variable` es una columna de factores que especifica dos o más grupos a los que pertenecen las muestras. Se pueden añadir otras columnas separándolas por `+` según el diseño de fórmulas habitual de R.  

Por defecto DebSeq2 va a preparar los contrastes de cada grupo con el primero de los factores, que será tenido como elemento de control. Por eso es importante que "coloquemos" los factores de tal forma que el primero sea ese. Esto se puede conseguir con la función `relevel`.  

En nuestro caso queremos hacer dos contrastes con el grupo de control NIT, pero también uno adicional entre ELI y SFI. Por tanto después de obtener los resultados para los primeros dos contrastes cambiamos el orden de los factores y obtenemos además el contraste buscado. Si lo hemos hecho correctamente, el contraste realizado dos veces pero en dirección distinta (SFI-NIT, NIT-SFI) tendrá los mismos coeficientes pero con los signos cambiados.  

```{r}
dds <- DESeqDataSetFromMatrix(countData = counts_sample,
                              colData = targets_sample,
                              design = ~ Group)
```


### Análisis exploratorio y visualización 

First, for visualization purposes, we will transform the data to make it easier to explore the relationships on it. But for the statistical analysis we will go back to use the full data.

## Pre filtering the data set for empty rows.  
We start by removing all rows which do have one or none count at all.  

```{r}
nrow(dds)
dds <- dds[ rowSums(counts(dds)) > 1, ]
nrow(dds)
```

## Variance stabilizing transformation and rlog

```{r}

vsd <- vst(dds, blind = FALSE)
rld <- rlog(dds, blind = FALSE)

dds <- estimateSizeFactors(dds)

df <- bind_rows(
  as_tibble(log2(counts(dds, normalized=TRUE)[, 1:2]+1)) %>%
         mutate(transformation = "log2(x + 1)"),
  as_tibble(assay(vsd)[, 1:2]) %>% mutate(transformation = "vst"),
  as_tibble(assay(rld)[, 1:2]) %>% mutate(transformation = "rlog"))
  
colnames(df)[1:2] <- c("x", "y")  
png("figures/vst.png", width = 680, height = 680)
print(ggplot(df, aes(x = x, y = y)) + geom_hex(bins = 80) +
  coord_fixed() + facet_grid( . ~ transformation))
dev.off()
```

We can see how genes with low counts (bottom left-hand corner) seem to be excessively variable on the ordinary logarithmic scale, while the VST and rlog compress differences for the low count genes for which the data provide little information about differential expression.  



# Resultados

# Discusión

# Conclusión

# Apéndice 1















## Samples distances

```{r}
sampleDists <- dist(t(assay(vsd)))

sampleDistMatrix <- as.matrix( sampleDists )
rownames(sampleDistMatrix) <- paste( vsd$dex, vsd$cell, sep = " - " )
colnames(sampleDistMatrix) <- NULL
colors <- colorRampPalette( rev(brewer.pal(9, "BuGn")) )(255)
png("figures/distmatrix.png", width = 680, height = 680)
print(pheatmap(sampleDistMatrix,
         clustering_distance_rows = sampleDists,
         clustering_distance_cols = sampleDists,
         col = colors))
dev.off()
```

## PCA plot

```{r}
plotPCA(vsd, intgroup = c("Group"))
```

# Differential Expression Analysis

```{r}
dds <- DESeq(dds, parallel =TRUE)
resultsNames(dds)
# Group_ELI_vs_NIT
res_ELIvNIT <- results(dds, contrast=c(0,1,0), alpha = 0.05)
# Group_SFI_vs_NIT
res_SFIvNIT <- results(dds, contrast=c(0,0,1), alpha = 0.05)

# Ahora cambiamos el orden de los factores para obtener la comparación que nos falta.

targets_sample$Group <- relevel(targets_sample$Group, "SFI")
dds <- DESeqDataSetFromMatrix(countData = counts_sample,
                              colData = targets_sample,
                              design = ~ Group)
dds <- DESeq(dds, parallel =TRUE)
resultsNames(dds)
# Group_NIT_vs_SFI
res_NITvSFI <- results(dds, contrast=c(0,1,0), alpha = 0.05)

# Group_ELI_vs_SFI
res_ELIvSFI <- results(dds, contrast=c(0,0,1), alpha = 0.05)
```
## Top genes

```{r}

topGenes_SFIvNIT <- as.data.frame(res_SFIvNIT) %>%
    rownames_to_column("GeneID") %>% 
    arrange(padj) %>% 
    head(100)
head(topGenes_SFIvNIT)
topGenes_ELIvNIT <- as.data.frame(res_ELIvNIT) %>%
    rownames_to_column("GeneID") %>% 
    arrange(padj) %>% 
    head(100)
head(topGenes_ELIvNIT)
topGenes_ELIvSFI <- as.data.frame(res_ELIvSFI) %>%
    rownames_to_column("GeneID") %>% 
    arrange(padj) %>% 
    head(100)
head(topGenes_ELIvSFI)

```

# Annotation

```{r}
columns(org.Hs.eg.db)

 # res_ELIvNIT$symbol <- mapIds(org.Hs.eg.db,
   #                   keys=row.names(res_ELIvNIT),
    #                  column="SYMBOL",
     #                 keytype="ENSEMBL",
      #                multiVals="first")
```

# Extra

b) Quality control of the raw data. 

```{r}
# Vemos que la distribución tiene un sesgo muy pronunciado. 
# Mostramos una de las muestras como ejemplo, pero ocurre lo mismo en todas.
qplot(counts_sample[,1], geom="histogram") 
# Log base 2 is typically used as it facilitates the conversion back to the original scale: 
# a difference of 1 on the log base 2 scale corresponds to a fold change of 2 on the original count scale. 
pseudoCount = log2(counts_sample + 1)
qplot(pseudoCount[,1], geom="histogram") 
```

# Información de la sesión de R

Incluimos la información sobre la sesión de R con la que se realizó el trabajo, para poder identificar después problemas ocasionados por cambios de versiones.  

```{r}
sessionInfo()
```

# Referencias




