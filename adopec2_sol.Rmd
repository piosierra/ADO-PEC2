---
title: "análisis de expresión genética diferencial en tiroides"
author: "Pío Alberto Sierra Rodríguez"
date: "14/6/2020"
output: 
  pdf_document:
    toc: true
    number_sections: true
  html_document:
    df_print: paged
params:
  counts_file: ./counts.csv
  targets_file: ./targets.csv
  samples: 10
bibliography: RNA-Seq.bib
---

```{r include = FALSE}
knitr::opts_chunk$set(echo = TRUE)
if(!(require(plyr))) 
  install.packages("plyr")
if(!(require(reshape))) 
  install.packages("reshape")
if(!(require(knitr))) 
  install.packages("knitr")
if(!(require(kableExtra))) 
  BiocManager::install("kableExtra")
if(!(require(dplyr))) 
  install.packages("dplyr")
if(!(require(ggplot2))) 
  install.packages("ggplot2")
if(!(require(RColorBrewer))) 
  install.packages("RColorBrewer")
if(!(require(DESeq2))) 
  install.packages("DESeq2")
if(!(require(pheatmap))) 
  install.packages("pheatmap")
if(!(require(tibble))) 
  install.packages("tibble")
if(!(require(AnnotationDbi))) 
  BiocManager::install("AnnotationDbi")
if(!(require(ashr))) 
  BiocManager::install("ashr")
if(!(require(org.Hs.eg.db))) 
BiocManager::install("org.Hs.eg.db")

```

***
**Repositorio de github:** https://github.com/piosierra/ADO-PEC2

***

# Abstract


# Objetivos

Queremos hacer un análisis de expresión genética diferencial a partir de tres muestras aleatorias de tiroides de `r params$samples` elementos, cada una de tres grupos diferentes:  

* *Not infiltrated tissues* (NIT)
* *Small focal infiltrates* (SFI)
* *Extensive lymphoid infiltrates* (ELI)
  
Para ello realizaremos los contrastes:  

* SFI-NIT
* ELI-NIT
* ELI-SFI
  
# Materiales y métodos

## Naturaleza de los datos

Los datos han sido obtenidos del Genotype-Tissue Expression project **[@noauthor_gtex_nodate]**. Se trata de 292 muestras pertenecientes tiroides en distintos estados de infiltración lifocitaria. Se trata de una sintomatología no muy habitual. Y de hecho el número de muestras de tipo ELI, las de mayor afectación, es reducido. **[@jimenez_varo_infiltracion_2013]**, **[@onoda_reactive_2014]**.  
Las muestras provienen de dos fuentes de datos. Por un lado las obtenidas por RNA-Seq (NGS), y por otro muestras provenientes de un trabajo separado para expresión de alelos (Allele-Specific Expression). 

## Métodos y herramientas

Hemos utilizado el lenguaje R [@noauthor_r_nodate] y las herramientas de Bioconductor, en particular la librería DebSeq2 [@love_deseq2_2020].  

 
## Workflow

### Lectura de datos

El informe está realizado a partir de dos archivos ya preparados. El archivo `r params$counts_file` contiene los conteos de las muestras del experimento para cada ensamble. El archivo `r params$targets` contiene los datos relacionados con cada una de las muestras.  
Los archivos utilizados en el estudio están correctamente formados y no faltan datos.

```{r include = FALSE}
# Leemos los archivos de datos
targets <- read.csv(params$targets_file)
counts <- read.csv2(params$counts_file, header = TRUE, row.names = 1)

# Comprobamos que no falta ningún dato
sum(is.na(targets))
sum(is.na(counts))
```
```{r echo=FALSE}
# Observamos la distribución de la media y la desviación estándar de las variables.
par(mfrow=c(1,2))
plot(apply(counts[-1],2,mean), main = "Medias de las muestras", xlab="", ylab="")
plot(apply(counts[-1],2,sd), main = "Desviación típica de las muestras", xlab="", ylab="")
```

En un archivo se usa "." como separador en el nombre de las muestras, y en el otro "-". Los igualamos para poder comparar y asegurarnos de que cruzamos los datos correctamente.

```{r include=FALSE}
colnames(counts) <-gsub("[.]","-", colnames(counts))
```

### Identificación de grupos y preparación de los datos

El número de observaciones que hay de cada grupo puede verse en la tabla 1.
```{r echo = FALSE}
kable_styling(knitr::kable(table(targets$Group), booktabs = TRUE,
                            caption = 'Muestras por grupo'),font_size = 10)
```
La variable que codifica el grupo ha de ser un factor, y es muy importante tener en cuenta que el primer elemento del factor será tomado como elemento de control, y será con el que se harán las comparaciones en el caso de fórmula de una sola variable.  
Para realizar los contrastes:  

* SFI-NIT  
* ELI-NIT  

Debemos de tener a NIT como primer factor. Mientras que para el último contraste:  

* ELI-SFI  

EL primer factor debe de ser SFI.  

Esta es una parte bastante delicada. Es importante para la correcta realización de las pruebas que los factores estén correctamente preparados. Esto puede comprobarse después comprobando los nombres de los contrastes preparados en el objeto *DESeqDataSet* con la instrucción `resultsNames`

```{r include = FALSE}
targets$Group <- as.factor(targets$Group)
targets$Group <- relevel(targets$Group, "NIT")
```


Para nuestro estudio vamos a tomar `r params$samples` muestras al azar de cada uno de los grupos. Para hacerlo sin tener que dividir el dataframe nos valemos de la función `ddply`, que permite aplicar una función a distintos conjuntos de un dataframe, y crea un dataframe de salida con las respuestas. Así la usamos para generar un dataframe con el número de muestras deseadas para cada grupo.  

Es importante haber comprobado antes que el número de muestras de cada grupo excede al de muestras a coger para el experimento, ya que si no los resultados no serán correctos.

```{r include = FALSE}
  
# Tomamos las muestras de targets.
set.seed(123999)
# Utilizamos la función ddply para obtener el mismo número de muestras de cada grupo del data frame,
# y devolver el resultado en un nuevo dataframe.
targets_sample <- ddply(targets,.(Group),function(x) x[sample(nrow(x),params$samples),])
table(targets_sample$Group)

# Y ahora las muestras correspondientes en counts
counts_sample <- counts[,which(colnames(counts) %in% targets_sample$Sample_Name)]

# Y finalmente las ordenamos de la misma forma según las indicaciones para usar DESeq2. 
targets_sample <- targets_sample[order(targets_sample$Group),]
counts_sample <- counts_sample[ , targets_sample$Sample_Name]
```
Un último paso muy importante es ordenar los dos dataframes, `counts` y `targets` para que el orden de las columnas del primero coincida con el orden de las filas del otro. *DebSeq2* no hace ninguna comprobación a la hora de cruzar los datos ni utiliza ningún campo como clave, se limita a cruzar por orden fila con columna, por lo que estas han de estar correctamente ordenadas.  
En la tabla 2 se puede ver el resultado parcial para las cinco primeras columnas y filas de la ordenación efectuada.  

```{r}
kable_styling(knitr::kable(data.frame("Columnas en counts" = head(colnames(counts_sample)),
                                      "Filas en targets" = head(targets_sample$Sample_Name)),
                           booktabs = TRUE,
                           caption = 'Ejemplo de las muestras correctamente ordenadas'),font_size = 10)
identical(colnames(counts_sample), targets_sample$Sample_Name)
```

### Control de calidad de los datos en bruto

Es necesario realizar un control de la calidad de los datos antes de proceder con el experimento. Para ello es conveniente transformar antes los datos ya que suelen mostrar un sesgo muy grande. La transformación $log_2"$ nos ayuda a normalizar las distribuciones para la visualización.

**ATENCIÓN:** Es muy importante no utilizar datos normalizados para crear el objeto *DESeqDataSet*. Las funciones que trabajan con él esperan los datos en bruto y ya se encargan ellas de realizar las transformaciones necesarias. 

En el apéndice de imágenes se pueden ver los datos normalizados por grupo de muestra. 

```{r include = FALSE}
pseudoCount = log2(counts_sample + 1)
df = melt(pseudoCount, variable_name = "Samples")
df = data.frame(df, group = targets_sample$Group[match(df$Samples, targets_sample$Sample_Name)])
png("figures/boxplotnorm.png", width = 680, height = 680)
ggplot(df, aes(x = Samples, y = value, fill = group)) + geom_boxplot() + xlab("") +
       ylab(expression(log[2](count + 1))) +  ggtitle("Cuentas normalizadas por grupo de muestra")
       theme(axis.title.x=element_blank(), axis.text.x=element_blank(),
        axis.ticks.x=element_blank())
dev.off()
```





### Creación del objeto DESeqDataSet 

DebSeq2 trabaja con un objeto *DESeqDataSet* que está construido sobre la clase *SummarizedExperiment*. Una de las diferencias fundamentales es que el objeto incluye una fórmula de diseño asociada, que será la que informa a muchas de las funciones que manipulen el objeto sobre cómo utilizar las muestras.  

Una fórmula puede ser de la forma `~ variable` donde `variable` es una columna de factores que especifica dos o más grupos a los que pertenecen las muestras. Se pueden añadir otras columnas separándolas por `+` según el diseño de fórmulas habitual de R.  

Por defecto DebSeq2 va a preparar los contrastes de cada grupo con el primero de los factores, que será tenido como elemento de control. Por eso es importante que "coloquemos" los factores de tal forma que el primero sea ese. Esto se puede conseguir con la función `relevel`.  

En nuestro caso queremos hacer dos contrastes con el grupo de control NIT, pero también uno adicional entre ELI y SFI. Por tanto después de obtener los resultados para los primeros dos contrastes cambiamos el orden de los factores y obtenemos además el contraste buscado. Si lo hemos hecho correctamente, el contraste realizado dos veces pero en dirección distinta (SFI-NIT, NIT-SFI) tendrá los mismos coeficientes pero con los signos cambiados.  

```{r}
dds <- DESeqDataSetFromMatrix(countData = counts_sample,
                              colData = targets_sample,
                              design = ~ Group)
```


### Análisis exploratorio y visualización 

Para realizar el análisis filtramos los datos para eliminar filas que solo tienen una observación. Se pueden elegir otros puntos de corte según el tipo de datos. En este caso como los conjuntos no son demasiado grandes nos basta con eliminar aquellos con solo una observación. Lo que nos deja de un número original de `r nrow(dds)` en solo `r nrow(dds[ rowSums(counts(dds)) > 1, ])`

```{r include = FALSE}
nrow(dds)
dds <- dds[ rowSums(counts(dds)) > 1, ]
nrow(dds)
```

### Transformación para estabilizar la varianza

El siguiente paso es transformar los datos para estabilizar la varianza 
```{r}

vsd <- vst(dds, blind = FALSE)
rld <- rlog(dds, blind = FALSE)

ddsn <- estimateSizeFactors(dds)

df <- bind_rows(
  as_tibble(log2(counts(ddsn, normalized=TRUE)[, 1:2]+1)) %>%
         mutate(transformation = "log2(x + 1)"),
  as_tibble(assay(vsd)[, 1:2]) %>% mutate(transformation = "vst"),
  as_tibble(assay(rld)[, 1:2]) %>% mutate(transformation = "rlog"))
  
colnames(df)[1:2] <- c("x", "y")  
png("figures/vst.png", width = 680, height = 680)
print(ggplot(df, aes(x = x, y = y)) + geom_hex(bins = 80) +
  coord_fixed() + facet_grid( . ~ transformation))
dev.off()
```

We can see how genes with low counts (bottom left-hand corner) seem to be excessively variable on the ordinary logarithmic scale, while the VST and rlog compress differences for the low count genes for which the data provide little information about differential expression.  

Como se trata de una comparación entre solo tres grupos, uno de control y otros dos. Un estudio de Principal Component Analysis nos permite identificar rápidamente si hay diferencias representativas en nuestros grupos. 

```{r include = FALSE}
png("figures/pca.png", width = 680, height = 680)
plotPCA(vsd, intgroup = c("Group"))
dev.off()
```
```{r}
sampleDists <- dist(t(assay(vsd)))

sampleDistMatrix <- as.matrix( sampleDists )
rownames(sampleDistMatrix) <- paste( vsd$dex, vsd$cell, sep = " - " )
colnames(sampleDistMatrix) <- NULL
colors <- colorRampPalette( rev(brewer.pal(9, "BuGn")) )(255)
png("figures/distmatrix.png", width = 680, height = 680)
print(pheatmap(sampleDistMatrix,
         clustering_distance_rows = sampleDists,
         clustering_distance_cols = sampleDists,
         col = colors))
dev.off()
```

### Análisis de expresión diferencial

Para realizar el análisi hemos utilizado la función `DESeq` y después obtenido los resultados con `resault`. A la hora de crear los resultados hemos tomado un punto de corte del p-valor $alpha = 0.05$. Para seleccionar la comparación a extraer para cada resultado hemos utilizado el parámetro `contrast` para seleccionar el contraste que previamente habíamos podido comprobar con `resultsNames`.


```{r}
dds <- DESeq(dds, parallel =TRUE)
resultsNames(dds)
# Group_ELI_vs_NIT
res_ELIvNIT <- results(dds, contrast =c("Group","ELI","NIT"), alpha = 0.05)
# Group_SFI_vs_NIT
res_SFIvNIT <- results(dds, contrast=c("Group","SFI","NIT"), alpha = 0.05)
# Group_NIT_vs_SFI
res_NITvSFI <- results(dds, contrast=c("Group","ELI","SFI"), alpha = 0.05)
# Ahora cambiamos el orden de los factores para obtener la comparación que nos falta.

res3 <- lfcShrink(dds, contrast=c("Group","ELI","SFI"), type="ashr")

```
Como vamos a enriquecer luego los datos y para compararlos mejor es conveniente proceder a la compresión de de los resultados de log2Fold. Esto en anteriores versiones se hacía por defecto y ahora se consigue con la función `lfcShrink`.

# Resultados

# Discusión

# Conclusión

# Apéndice 1

















## Top genes

```{r}

topGenes_SFIvNIT <- as.data.frame(res_SFIvNIT) %>%
    rownames_to_column("GeneID") %>% 
    arrange(padj) %>% 
    head(100)
head(topGenes_SFIvNIT)
topGenes_ELIvNIT <- as.data.frame(res_ELIvNIT) %>%
    rownames_to_column("GeneID") %>% 
    arrange(padj) %>% 
    head(100)
head(topGenes_ELIvNIT)
topGenes_ELIvSFI <- as.data.frame(res_ELIvSFI) %>%
    rownames_to_column("GeneID") %>% 
    arrange(padj) %>% 
    head(100)
head(topGenes_ELIvSFI)

```

# Annotation

```{r}
columns(org.Hs.eg.db)

 # res_ELIvNIT$symbol <- mapIds(org.Hs.eg.db,
   #                   keys=row.names(res_ELIvNIT),
    #                  column="SYMBOL",
     #                 keytype="ENSEMBL",
      #                multiVals="first")
```

# Apéndice A - Figuras

\begin{center}Fig.1: Boxplot for raw data\end{center}
 
![Boxplot Norm](figures/boxplotnorm.png)




# Información de la sesión de R

Incluimos la información sobre la sesión de R con la que se realizó el trabajo, para poder identificar después problemas ocasionados por cambios de versiones.  

```{r}
sessionInfo()
```

targets_sample$Group <- relevel(targets_sample$Group, "SFI")
dds <- DESeqDataSetFromMatrix(countData = counts_sample,
                              colData = targets_sample,
                              design = ~ Group)
dds <- DESeq(dds, parallel =TRUE)
resultsNames(dds)
# Group_NIT_vs_SFI
res_NITvSFI <- results(dds, contrast=c(0,1,0), alpha = 0.05)

# Group_ELI_vs_SFI
res_ELIvSFI <- results(dds, contrast=c(0,0,1), alpha = 0.05)

# Referencias




